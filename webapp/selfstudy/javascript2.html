<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
	<script type="text/javascript" src="/jqueryex/jquery/jquery-1.12.4.js"></script>
</head>
<body>

</body>

	<script type="text/javascript">
	
	//var 는 let 이나 const 랑 다르게 호이스팅이 된다 let과 const는 TDZ 템포럴 데드존 그러니까 변수안의 값이 선언되지 않은곳에서는 사용불가능하다(선언 전에) 반면 var는 tdz없이 호이스팅되어 다 사용가능하다
	
	//var는 함수 스코프 let, const는 블록스코프이다 함수 if for while try/catch등에서 쓰인다 {}안에서만 쓰임 예외로var도 함수 밖으로 나갈수 없다.
	//var보단 const로주로 써야 예측불가능한 버그를 줄인다.
	
	//생성자 함수
	//ex1
	function Users(name, age){
	    this.name = name;
	    this.age = age;
	    this.sayName = function(){
	        console.log(this.name + "입니다!");
	    }
	}
	
	let user1 = new Users("김만덕", 62);
	user1.sayName();
	//ex2
	function Item(title, price){
	    this.title = title;
	    this.price = price;
	    this.showPrice = function(){
	        console.log(title+ "의 가격은"+ price + "입니다");
	    }
	}
	
	const item1 = new Item("펜더", 3200000);
	const item2 = new Item("깁슨", 5800000);
	const item3 = new Item("존써", 4300000);
	
	
	item1.showPrice();
	item2.showPrice();
	item3.showPrice();
	
	console.log(item1, item2, item3);
	
	//computed property
	//ex1
	let n = "name";
	let a = "age";
	
	const user = {
		[n] : "mike",
		[a] : "30",
		[1 +4] : 5, //이건 뭘까 계산식을 넣을 수 있는데 왜넣는걸까
	}
	
	console.log(user);
	//ex2
	function makeObj(key, val){
	    return{
	        [key] : val,
	    };
	}
	
	const obj = makeObj("나이", 30);	
	console.log(obj);
	
	//복사할때
	const userid = {
		name: "mike",
		age: 30,
	};
	//Object.assign({초기값}, 가져올변수);을 사용해야 원래것에 훼손을 주지 않고 값만 복사해서 새로 사용할 수 있다.
	const user2 = Object.assign({}, userid);
	user2.name = "김갑룡";
	console.log(user2);
	console.log(userid);
	//Object.keys(); == key값들만 보려고 할때
	console.log(Object.keys(user2)); //name, age
	//Object.values(); == 벨류값만 보고자 할 때
	console.log(Object.values(userid)); // "김갑룡", 30;
	//Object.entries(); 하면 키 벨류  둘다 보여준다 배열로 만들어서 보여준다.
	const result = Object.entries(user2);
	console.log(result);
	
	//Object.fromEntries(); 배열을 객체로 만들어준다.
	let arr = [
	    ["mon", '월'],
	    ["tue", '화'],
	    ['sun', '해'],
	]
	const arrResult = Object.fromEntries(arr);
	console.log(arrResult);
	
	//symbol: 유일성 보장
	const id = Symbol('id');
	const user3 = {
		name : 'Mike',
		age : 30,
		[id] : 'myid'
	}
	//Object.keys(), values(),entries() 는 Symbol을 출력하지 않는다.
	console.log(Object.keys(user3));
	//그렇다면 심볼은 어디다가쓸까? 바로 원본을 변형하지 않고 사용해야할때 자신만의 필드값을 넣어주기 위해 사용한다. 그러면 원본은 유지한체 사용 가능하다
	        
	//전역 심볼 symbol.for() 하나 생성후 키를 통해 같은 Symbol을 공유
	const favFood = Symbol.for('햄버거');
	const pigFood = Symbol.for('햄버거'); //햄버거라는 키값을 통해 fav와 pigfood가 같은 심볼값을 공유한다는걸 알 수 있다.
	
	console.log(favFood === pigFood);
	//key 값을 알고싶으면 Symbol.KeyFor();을 사용하면 알려준다.
	//console.log(Symbol.KeyFor(favFood)); 뭐지? 키포 없는 펑션이라는데?
	console.log(favFood.description); //전역 키for가 아니라면 이걸로 알 수 있다.
	
	//심볼은 온전히 숨길 수 없다.
	console.log(Object.getOwnPropertySymbols(favFood)); //를 사용하면 모든 심볼들을 보여준다.
	console.log(Reflect.ownKeys(user)); //하면 모든 키를 보여준다.
	//근데 대부부분 잘 안쓴단다.
	
	
	//number, Math
	//toString(); 숫자를 문자로 바꿔준다. ()안에 숫자를 쓰면 그 숫자의 진법으로 바꿔준다.
	let num1 = 10;
	console.log(num1.toString(2)); // == 1010
	let num2 = 255;
	console.log(num2.toString(16)); //색깔에서 많이쓰이는 16진수이다. == ff
	//Math는 자바에서 가지고 있는 내장 객체이다.
	console.log(Math.PI);//pi값을 보여준다.
	//Math.ceil() == 올림이다.
	console.log(Math.ceil(5.12));
	console.log(Math.ceil(6.98));
	//Math.floor() == 내림
	console.log(Math.floor(5.12));
	console.log(Math.floor(6.98));
	//Math.round() == 반올림
	console.log(Math.round(5.12));
	console.log(Math.round(6.98));
	//소숫점 셋째 자리에서 반올림 하여 둘째자리까지 출력하라
	let userRate = 30.1287;
	console.log(userRate.toFixed);
	
	
	
	    
	
	</script>
</html>