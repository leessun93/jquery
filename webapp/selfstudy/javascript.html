<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
	<script type="text/javascript" src="/jqueryex/jquery/jquery-1.12.4.js"></script>
</head>
<body>

</body>

	<script type="text/javascript">
	
	name = "mike";
	console.log(name);
	/* 이 경우 큰 프로젝트에서 다른사람이 name이라는 변수를 사용할 수 있음으로 위험하다 따라서 let을 쓰자 */
	//let name = "james";
	/*라고 사용하면 위에서 name을 사용하였기 때문에 오류로 나타내준다  */
	console.log(name);
	
	const PI = 3.14;
	//const는 *절대 변하지 않을 상수*를 나타낸다 변수도 다른사람이 알기 쉽게 대문자로 표현해주는게 좋다.
	//대형 프로젝트를 할때는 일단 콘스트로 해주고 나중에 렛으로 바꿔주면 중복이 없어 좋다고 한다.
	console.log('my name is' + name); //인데 자바스크립트에서는"my name is ${name}" 이라고 써준다고 한다.
	
	//alert 알려줌 prompt 입력받음 confirm 확인받음 
	alert("hellow world"); //새로운 팝업창으로 띄워줌 확인누르면 사라짐 일방적으로 알림
	const getname = prompt("이름을 입력하세요", "age = 30"); //팝업창에서 값을 받을때 사용한다. 미리 들어갈 디폴트값(placehold)도 넣어줄수있다
	
	const isAdult = confirm("당신은 성인입니까?"); //얼트는 확인만 나오지만 컨핌은 확인 취소 두개가 나와서 불린처럼 트루 펄스로 값을 받는다.
	console.log(isAdult);
	/*alert prompt confirm 의 단점은 처리될때까지 스크립트가 멈춤, css로 스타일링이 불가능 따라서 그냥 쓰지말자 너무 촌시럽다. 디자이너가 싫어함*/
	
	//String() Number() Boolean() 으로 형변환이 가능하다.
	console.log(Number(true), Number(false))// 특이하게 트루펄스는 넘버로 형변환시 true 1과 false 0을 반환한다.
	//Boolean() 으로 형변환시 0, 빈 문자열, null, undefined, NaN 은 false로 변환된다.
	//주의사항
	console.log(Boolean(0)); //false
	console.log(Boolean('0')); //true
	console.log(Boolean('')); //false
	console.log(Boolean(' ')); //ture
	
	//연산자 줄여쓰기
	let num = 10;
	//num = num + 5;
	//console.log(num); // 15인데 이걸 더 줄여 써보자
	num /= 5;
	console.log(num);
	// += -= *= %= /= 등등으로 사용가능하다.
	
	//if문 자바랑 똑같다 쉬움
	let getAge = 19
	if(getAge > 19){
	    console.log("성인인증이 완료되었습니다.");
	}else if(getAge <0){
	    console.log("잘못 입력하셨습니다.");
	}else{
	    console.log("쪼꼬만게 어서 집에가 임마");
	}
	
	// ||(==or) 하나라도 ture면 true 모두 false여야 false, &&(==and) 모든값이 true여야 true 하나라도 false 이면 false, !(==not) ture면 false false면 true
	
	//for문 도 똑같음 쉽다.
	for(let i = 0; i<12; i++ ){
	    console.log(i + "숫자");
	}
	
	//while문도 똑같다.
	let i = 1;
	while(i <10){
	 	console.log("while 입니다" + i);   
	    i++;
	}
	//do, break, continue 도 똑같다.
	//swith case 문도 똑같다.
	let food = "파스타";
	switch(food){
		case '파스타' :
		    console.log("느끼");
		    break;
		case '긴띠띠개' :
		    console.log("짜");
		    break;
		case '피자' :
		    console.log("살찜");
		    break;
		case '술' :
		    console.log("달림");
		    break;
		default :
		    console.log("사람이 못먹는겁니다.");
	}
	
	
	//함수 function
	function showError(){
	    alert("에러가 발생했습니다 다시 시도해주세요");
	}
	showError();
	
	function sayHello(name){
	    let msg = 'Hellow';
	    if(name){
	        msg += name;
	    }
	    console.log(msg);
	}
	sayHello('james');
	//함수 호출하고 나면 변수 값이 바뀐다 딱히 리턴값을 안주는데 바뀌나보다
	
	//전역 변수와 지역 변수
	//함수내부에서 지역변수로 let을 선언해주면 지역변수의 let 같은변수에 영향을 주지 않는다.
	
	let hi = "안녕하세요";
	console.log(hi);
	
	function hihi(){
	    let hi = "안녕못해요";
	    console.log(hi);
	}
	hihi(); //hihi 펑션에서  let hi 로 안녕못해요를 바꿔주어도 펑션 밖에서는 작용하지않는다. 위에서는 반환타입이 없어도 그냥 변수선언으로 바뀌었지만 같은 let을 써주니 서로 바뀌지않았다.
	console.log(hi);
	
	//or
/* 	function friend(name){
	    let newName = name || "friend";// 네임이라는 값을 받으면 그 값을 넣고 아니면 friend로 한다
	    let msg = 'hello,' + newName;
	    console.log(msg)
	} */
	
	function friend(name = "friend"){ //이런식으로 값이 없을때의 디폴트 값을 넣어줄 수 있다.
	    let msg = 'hello,' + name;
	    console.log(msg)
	}
	
	
	friend();
	friend('good');
	
	
	//자바스크립트가 처음 로딩될대 전부 한번씩 읽어서 함수를 미리 찾아두는걸 호이스팅이라고함 
	//함수 선언문
	showError();
	
/*	let showError = function(){
	    console.log('error');
	}*/ //이 경우 함수가 순서대로 작동하기 때문에 작동이 안된다.
	
	function showError(){
	    console.log('error');
	} //이 경우 호이스팅이 작동되어 호출이 먼저 나와도 작동한다.
	
	//화살표 함수 오히려 복잡하니 안쓰는게 좋겠다.
	const add = (num1, num2) =>(num1 + num2); //리턴을 빼고 한줄로 만듬 근데 자바랑 섞이면 더 복잡해질듯
	
	//객체
	const superman={ //클래스이름
		name : 'clark', //필드값 선언
		age : 30
	}
	
	console.log(superman.name);
	console.log(superman.age);
	
	superman.haircolor = "black";// 이런식으로 외부에서 필드값을 세팅 가능
	superman["hobby"] = "diablo2";// 이렇게도 선언 가능
	console.log(superman);
	
	delete superman.age; //이런식으로 지우기도 가능
	console.log(superman); 
	
	//객체 만들기 함수
	function makeObject(name, age){
	    return{
	        name,
	        age,
	        hobby : 'soccer'
	    }
	}
	
	const mike = makeObject('mike', 30);
	console.log(mike);
	
	console.log("age" in mike); //마이크라는 변수에 age 필드가 존재하느냐? true
	console.log('birthday' in mike); //마이크라는 변수에 birthday가 존재하느냐> false
	
	//객채 for in문
	const kim = {
		name : "kim",
		age : 30
	};
	
	for(x in kim){
	    console.log(kim[x]); //kim['name'], kim['age'] 이렇게 한번씩 돔
	}
	
	
	//메소드에서는 this 를 써주는게 좋다.
	
	//array 	
	let student = ['김복자', '양문희', '김갑수', '이칠복', '강경자', '최삼돌'];
	console.log(student[1]); //양문희 //똑같다 0번부터~
	
	//배열은 str, int, function 등 한번에 다양한걸 넣을 수 있다
	//배열의 길이는 .length를 사용한다
	
	student.push("남궁복순"); //배열 맨뒤에 추가해준다 append와 같다.
	console.log(student);
	
	student.pop(); //배열의 맨 끝을 지워준다 파이썬과 같다.
	console.log(student); //냄궁복순을 지웠다.
	
	student.unshift("김경남"); // 배열의 맨 앞에 추가해준다
	console.log(student);
	
	student.shift(); //배열의 맨 앞을 지워준다.
	console.log(student); 
	
	//for of 로 사용하자 for in은 오류가 많다. 그냥 자바에서 배운 for문으로 쓰는게 안햇가리고 좋겠다.
	
	for(let students of student){
	    console.log(students);
	} //포문으로 돌면서 하나씩 출력해준다 파이썬과 비슷하다.
	
	
	
	
	</script>
	
</html>